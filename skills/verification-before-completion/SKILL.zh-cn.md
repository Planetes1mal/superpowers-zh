---
name: verification-before-completion
description: 在即将声称工作完成、修复或通过时，在提交或创建 PR 之前使用 - 要求运行验证命令并确认输出，然后再做任何成功声明；始终证据先于断言
---

# 完成前验证 (Verification Before Completion)

## 概述

声称工作完成而没有验证是欺骗，不是效率。

**核心原则：** 始终证据先于声明。

**违反此规则的字面意思就是违反规则的精神。**

## 铁律

```
没有新鲜验证证据就没有完成声明
```

如果你没有在此消息中运行验证命令，你就不能声称它通过。

## Gate Function

```
在声称任何状态或表达满意之前：

1. IDENTIFY: 什么命令证明这个声明？
2. RUN: 执行完整的命令（新鲜、完整）
3. READ: 完整输出，检查退出代码，统计失败
4. VERIFY: 输出是否确认声明？
   - 如果 NO: 用证据陈述实际状态
   - 如果 YES: 用证据陈述声明
5. ONLY THEN: 做出声明

跳过任何步骤 = 撒谎，不是验证
```

## 常见失败

| 声明 | 需要 | 不足够 |
|-------|----------|----------------|
| 测试通过 | 测试命令输出：0 失败 | 之前运行，"应该通过" |
| Linter 干净 | Linter 输出：0 错误 | 部分检查，推断 |
| 构建成功 | 构建命令：exit 0 | Linter 通过，日志看起来好 |
| Bug 修复 | 测试原始症状：通过 | 代码变更，假设修复 |
| 回归测试工作 | 红-绿周期验证 | 测试通过一次 |
| Agent 完成 | VCS diff 显示变更 | Agent 报告"成功" |
| 需求满足 | 逐行检查清单 | 测试通过 |

## 警告标志 - 停止

- 使用 "should"、"probably"、"seems to"
- 在验证前表达满意（"Great!"、"Perfect!"、"Done!" 等）
- 未验证就要提交/推送/PR
- 信任 agent 成功报告
- 依赖部分验证
- 想着"就这一次"
- 累了想让工作结束
- **任何暗示成功而没有运行验证的措辞**

## 合理化预防

| 借口 | 现实 |
|--------|---------|
| "现在应该有效" | 运行验证 |
| "我有信心" | 信心 ≠ 证据 |
| "就这一次" | 没有例外 |
| "Linter 通过" | Linter ≠ 编译器 |
| "Agent 说成功" | 独立验证 |
| "我累了" | 疲惫 ≠ 借口 |
| "部分检查足够" | 部分证明不了什么 |
| "不同的话所以规则不适用" | 精神重于字面 |

## 关键模式

**测试：**
```
✅ [运行测试命令] [看: 34/34 通过] "所有测试通过"
❌ "现在应该通过" / "看起来正确"
```

**回归测试（TDD 红-绿）：**
```
✅ 编写 → 运行（通过）→ 还原修复 → 运行（必须失败）→ 恢复 → 运行（通过）
❌ "我已经写了回归测试"（没有红-绿验证）
```

**构建：**
```
✅ [运行构建] [看: exit 0] "构建通过"
❌ "Linter 通过"（linter 不检查编译）
```

**需求：**
```
✅ 重读计划 → 创建检查清单 → 验证每个 → 报告差距或完成
❌ "测试通过，阶段完成"
```

**Agent 委派：**
```
✅ Agent 报告成功 → 检查 VCS diff → 验证变更 → 报告实际状态
❌ 信任 agent 报告
```

## 为什么这很重要

来自 24 次失败记忆：
- 您的人类伙伴说 "I don't believe you" - 信任破裂
- 未定义函数发货 - 会崩溃
- 缺失需求发货 - 不完整功能
- 时间浪费在虚假完成 → 重定向 → 返工
- 违反："Honesty is a core value. If you lie, you'll be replaced."

## 何时应用

**始终在以下之前：**
- 任何成功/完成声明的变体
- 任何满意的表达
- 关于工作状态的任何积极陈述
- 提交、PR 创建、任务完成
- 移动到下一个任务
- 委派给 agents

**规则适用于：**
- 确切短语
- 改写和同义词
- 成功的暗示
- 任何暗示完成/正确性的沟通

## 底线

**验证没有捷径。**

运行命令。阅读输出。然后声明结果。

这是不可协商的。
